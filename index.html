<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LLM Agent POC</title>
    <link rel="icon" type="image/x-icon" href="logo.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css" />
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />

    <script async src="https://trackerbea.pythonicvarun.me/tracker.js"
        data-trackerbea-server="https://trackerbea.pythonicvarun.me"
        data-trackerbea-domain-id="8f0f891c-1017-40b7-ab31-6fa1597863a4"
        data-trackerbea-opts='{ "detailed": true }'></script>
    <style>
        :root {
            --body-bg: #f5f5f5;
            --chat-bg: #ffffff;
            --sidebar-bg: #ffffff;
            --sidebar-border: #dee2e6;
            --user-bubble-bg: #0d6efd;
            --agent-bubble-bg: #e9ecef;
            --tool-bubble-bg: #f8f9fa;
            --sidebar-width: 280px;
            /* Scrollbar theme (match Bootstrap neutrals) */
            --scrollbar-thumb: #ced4da;
            --scrollbar-thumb-hover: #adb5bd;
            --scrollbar-track: var(--chat-bg);
        }

        body {
            background-color: var(--body-bg);
            font-family: "Inter", sans-serif;
        }

        .app-container {
            height: 100vh;
            display: flex;
        }

        .sidebar {
            width: var(--sidebar-width);
            background-color: var(--sidebar-bg);
            border-right: 1px solid var(--sidebar-border);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            position: fixed;
            top: 0;
            left: 0;
            height: 100vh;
            z-index: 1000;
        }

        .sidebar-header {
            padding: 1rem;
            border-bottom: 1px solid var(--sidebar-border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .new-chat-btn {
            width: 100%;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
        }

        .chat-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .chat-item {
            display: flex;
            color: black;
            border-radius: 0.5rem;
            margin-bottom: 0.25rem;
            padding-right: 0.75rem;
        }

        .chat-item.active {
            color: white;
            background-color: var(--user-bubble-bg);
        }

        .chat-item-btn {
            width: 100%;
            max-width: 13.15rem;
            text-align: left;
            border: none;
            background: transparent;
            padding: 0.75rem;
            border-radius: 0.5rem;
            color: #495057;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
        }

        .chat-item-btn:hover {
            background-color: #f8f9fa;
        }

        .chat-item-btn.active {
            background-color: var(--user-bubble-bg);
            color: white;
        }

        .chat-title {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            margin-right: 0.5rem;
            text-align: left;
        }

        .chat-actions {
            display: flex;
            gap: 0.25rem;
            opacity: 0.6;
            transition: opacity 0.2s;
            flex-shrink: 0;
            margin-left: auto;
        }

        .chat-item-btn:hover .chat-actions {
            opacity: 1;
        }

        .chat-item-btn.active .chat-actions {
            opacity: 0.8;
        }

        .chat-action-btn {
            border: none;
            background: transparent;
            padding: 0.25rem;
            border-radius: 0.25rem;
            color: inherit;
            font-size: 0.8rem;
        }

        .chat-action-btn:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            margin-left: var(--sidebar-width);
        }

        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background-color: var(--chat-bg);
        }

        .chat-header {
            background: #ffffff;
            border-bottom: 1px solid #dee2e6;
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: fixed;
            width: calc(100vw - var(--sidebar-width));
            left: var(--sidebar-width);
            top: 0;
            z-index: 999;
        }

        #chat-window {
            flex-grow: 1;
            background-color: var(--chat-bg);
            padding: 1.5rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin: 5rem 0;
        }

        .message-wrapper {
            display: flex;
            gap: 0.75rem;
            max-width: 100%;
        }

        .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            flex-shrink: 0;
        }

        .avatar-user {
            background-color: var(--user-bubble-bg);
            color: white;
        }

        .avatar-agent {
            background-color: var(--agent-bubble-bg);
            color: #343a40;
        }

        .message {
            padding: 0.75rem 1.25rem;
            border-radius: 1.25rem;
            word-wrap: break-word;
        }

        .user-message {
            background-color: var(--user-bubble-bg);
            color: white;
            border-bottom-right-radius: 0.25rem;
            max-width: 68.5vw;
        }

        .agent-message {
            max-width: 68.5vw;
            background-color: var(--agent-bubble-bg);
            color: #212529;
            overflow-x: auto;
            border-bottom-left-radius: 0.25rem;
        }

        .message-wrapper.user {
            align-self: flex-end;
            flex-direction: row-reverse;
        }

        .message-wrapper.agent {
            align-self: flex-start;
        }

        .system-event {
            /* max-width: 68.5vw; */
            align-self: center;
            width: 100%;
            margin: 0.5rem 0;
        }

        .tool-message {
            background-color: var(--tool-bubble-bg);
            color: #495057;
            font-family: monospace;
            font-size: 0.85rem;
            width: 100%;
            text-align: center;
            border-radius: 0.5rem;
            padding: 0.5rem;
            border: 1px solid #dee2e6;
        }

        .agent-message pre {
            position: relative;
            background-color: #212529;
            color: #f8f9fa;
            padding: 1rem;
            border-radius: 0.5rem;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .tool-calls-final pre {
            position: relative;
            background-color: #212529;
            color: #f8f9fa;
            padding: 1rem;
            border-radius: 0.5rem;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .copy-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background-color: #495057;
            color: white;
            border: none;
            padding: 0.25rem 0.6rem;
            border-radius: 0.3rem;
            font-size: 0.8rem;
            cursor: pointer;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .agent-message pre:hover .copy-btn {
            opacity: 1;
        }

        .chat-composer {
            bottom: 0;
            width: calc(100vw - var(--sidebar-width));
            left: var(--sidebar-width);
            position: fixed;
            padding: 1rem 1.5rem;
            background-color: #ffffff;
            border-top: 1px solid #dee2e6;
        }

        #chat-form {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        #user-input {
            flex-grow: 1;
            border-radius: 2rem;
            padding: 0.6rem 1.2rem;
            border: 1px solid #ced4da;
        }

        #submit-button {
            border-radius: 50%;
            width: 48px;
            height: 48px;
            flex-shrink: 0;
        }

        .accordion-button:not(.collapsed) {
            background-color: var(--agent-bubble-bg);
            color: #212529;
            box-shadow: none;
        }

        code[class*=language-],
        pre[class*=language-] {
            text-shadow: unset !important;
        }

        .token.operator {
            background: unset !important;
        }

        /* WebKit-based browsers */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--scrollbar-track);
        }

        ::-webkit-scrollbar-thumb {
            background-color: var(--scrollbar-thumb);
            border-radius: 10px;
            border: 2px solid var(--scrollbar-track);
        }

        ::-webkit-scrollbar-thumb:hover {
            background-color: var(--scrollbar-thumb-hover);
        }

        ::-webkit-scrollbar-corner {
            background: transparent;
        }

        /* Firefox */
        html {
            scrollbar-width: thin;
            scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
        }

        .agent-message {
            border-collapse: collapse;
        }

        .agent-message table {
            margin-bottom: 1rem;
        }

        .agent-message th,
        .agent-message td {
            padding: 10px;
            text-align: left;
            border: 1px solid #000;
        }

        .agent-message th {
            background-color: #f4f4f4;
            font-weight: bold;
        }

        .agent-message tbody tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        .agent-message tbody tr:hover {
            background-color: #eaeaea;
        }

        @media only screen and (max-width: 767px) {

            /* Slightly thinner scrollbars on small screens */
            ::-webkit-scrollbar {
                width: 6px;
                height: 6px;
            }

            .sidebar {
                width: 250px;
                position: fixed;
                left: -250px;
                top: 0;
                height: 100vh;
                z-index: 1050;
                transition: left 0.3s ease;
                box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
            }

            .sidebar.show {
                left: 0;
            }

            .sidebar-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background-color: rgba(0, 0, 0, 0.5);
                z-index: 1040;
                display: none;
            }

            .sidebar-overlay.show {
                display: block;
            }

            .main-content {
                width: 100%;
                margin-left: 0;
            }

            .mobile-header {
                z-index: 999;
                position: fixed;
                width: 100%;
                display: flex;
                align-items: center;
                padding: 1rem;
                background: white;
                border-bottom: 1px solid var(--sidebar-border);
            }

            .mobile-menu-btn {
                margin-right: 1rem;
                border: none;
                background: transparent;
                font-size: 1.2rem;
            }

            .message-wrapper.agent {
                flex-direction: column;
            }

            .agent-message {
                max-width: 90vw;
            }

            .chat-header {
                width: 100vw;
                left: 0;
            }

            .chat-composer {
                width: 100vw;
                left: 0;
            }
        }

        @media only screen and (min-width: 768px) {
            .mobile-header {
                display: none;
            }

            .sidebar-overlay {
                display: none !important;
            }
        }
    </style>
</head>

<body>
    <div class="app-container">
        <!-- Sidebar -->
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <div>
                    <h5 class="mb-0">ü§ñ LLM Agent</h5>
                    <small class="text-muted">Multi-tool agent</small>
                </div>
                <button class="btn btn-outline-secondary btn-sm" type="button" data-bs-toggle="modal"
                    data-bs-target="#appSettingsModal" title="Settings">
                    <i class="bi bi-gear-fill"></i>
                </button>
            </div>
            <div class="sidebar-content">
                <button class="btn btn-primary new-chat-btn" id="new-chat-btn">
                    <i class="bi bi-plus-lg me-2"></i>New Chat
                </button>
                <ul class="chat-list" id="chat-list">
                    <!-- Chat items will be populated here -->
                </ul>
            </div>
        </div>

        <!-- Sidebar overlay for mobile -->
        <div class="sidebar-overlay" id="sidebar-overlay"></div>

        <!-- Main content -->
        <div class="main-content">
            <!-- Mobile header -->
            <div class="mobile-header">
                <button class="mobile-menu-btn" id="mobile-menu-btn">
                    <i class="bi bi-list"></i>
                </button>
                <div>
                    <h5 class="mb-0">ü§ñ LLM Agent</h5>
                </div>
                <div class="ms-auto">
                    <button id="clear-chat-btn" class="btn btn-outline-danger btn-sm me-2" type="button"
                        title="Clear Chat History">
                        <i class="bi bi-trash"></i>
                    </button>
                </div>
            </div>

            <div class="chat-container">
                <header class="chat-header d-none d-md-flex">
                    <div>
                        <h4 class="mb-0" id="chat-title">New Chat</h4>
                        <p class="text-muted mb-0 small">A browser-based multi-tool agent</p>
                    </div>
                    <div class="d-flex align-items-center">
                        <button id="clear-chat-btn-desktop" class="btn btn-outline-danger me-2" type="button"
                            title="Clear Chat History">
                            <i class="bi bi-trash"></i>
                        </button>
                    </div>
                </header>

                <div id="chat-window"></div>

                <div class="chat-composer">
                    <form id="chat-form">
                        <input type="text" id="user-input" class="form-control" placeholder="Type your message..."
                            autocomplete="off" />
                        <button type="submit" id="submit-button"
                            class="btn btn-primary fs-5 d-flex align-items-center justify-content-center">‚û§</button>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="appSettingsModal" tabindex="-1" data-bs-backdrop="static" data-bs-keyboard="false">
        <div class="modal-dialog modal-lg modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Settings</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <ul class="nav nav-tabs" id="settingsTabs" role="tablist">
                        <li class="nav-item" role="presentation">
                            <button class="nav-link active" id="agent-tab" data-bs-toggle="tab"
                                data-bs-target="#agent-tab-pane" type="button">Agent</button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="keys-tab" data-bs-toggle="tab" data-bs-target="#keys-tab-pane"
                                type="button">API Keys</button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="provider-tab" data-bs-toggle="tab"
                                data-bs-target="#provider-tab-pane" type="button">Provider</button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="data-tab" data-bs-toggle="tab" data-bs-target="#data-tab-pane"
                                type="button">Data</button>
                        </li>
                    </ul>
                    <div class="tab-content pt-4" id="settingsTabsContent">
                        <div class="tab-pane fade show active" id="agent-tab-pane">
                            <div class="mb-3">
                                <label for="apiModel" class="form-label">Model</label>
                                <select class="form-select" id="apiModel"></select>
                                <small class="form-text text-muted">Select a model to use. Fetch models from the
                                    'Provider' tab.</small>
                            </div>
                            <hr />
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" role="switch" id="toolsEnabledSwitch" />
                                <label class="form-check-label" for="toolsEnabledSwitch">Enable Tool Usage</label>
                            </div>
                            <small class="form-text text-muted">Allow the agent to use tools like Google Search and Code
                                Execution.</small>
                        </div>
                        <div class="tab-pane fade" id="keys-tab-pane">
                            <div class="mb-3">
                                <label for="apiKey" class="form-label">LLM Provider API Key</label>
                                <input type="password" class="form-control" id="apiKey" placeholder="sk-..." />
                            </div>
                            <hr />
                            <div class="mb-3">
                                <label for="serperApiKey" class="form-label d-flex justify-content-between">
                                    <span>Serper API Key (for Google Search)</span>
                                    <a href="https://serper.dev" target="_blank">Get a free key <i
                                            class="bi bi-box-arrow-up-right"></i></a>
                                </label>
                                <input type="password" class="form-control" id="serperApiKey"
                                    placeholder="Enter your Serper.dev key" />
                            </div>
                        </div>
                        <div class="tab-pane fade" id="provider-tab-pane">
                            <div class="mb-3">
                                <label for="apiBaseUrl" class="form-label">API Base URL</label>
                                <input type="text" class="form-control" id="apiBaseUrl"
                                    placeholder="https://api.openai.com/v1" />
                                <small class="form-text text-muted">The endpoint for your OpenAI-compatible
                                    provider.</small>
                            </div>
                            <button class="btn btn-primary" type="button" id="saveAndFetchModels">
                                <span class="spinner-border spinner-border-sm d-none" role="status"></span>
                                Fetch Models & Save Provider
                            </button>
                        </div>
                        <div class="tab-pane fade" id="data-tab-pane">
                            <div class="mb-4">
                                <h6 class="mb-3">Chat Management</h6>
                                <div class="d-grid gap-2">
                                    <button class="btn btn-outline-danger" type="button" id="clearAllChatsBtn">
                                        <i class="bi bi-trash3 me-2"></i>Clear All Chats
                                    </button>
                                </div>
                                <small class="form-text text-muted mt-2 d-block">This will permanently delete all chat
                                    conversations from your browser's storage.</small>
                            </div>
                            <hr />
                            <div class="mb-3">
                                <h6 class="mb-3">Storage Information</h6>
                                <div class="row">
                                    <div class="col-sm-6">
                                        <small class="text-muted">Total Chats:</small>
                                        <div class="fw-bold" id="totalChatsCount">0</div>
                                    </div>
                                    <div class="col-sm-6">
                                        <small class="text-muted">Storage Used:</small>
                                        <div class="fw-bold" id="storageUsed">0 KB</div>
                                    </div>
                                </div>
                            </div>
                            <hr />
                            <div class="mb-3">
                                <h6 class="mb-3">Memory <button id="clearMemoriesBtn" class="btn btn-sm btn-outline-danger float-end">Clear All</button></h6>
                                <ul id="memoryList" class="list-group mt-2" style="max-height:200px;overflow:auto;"></ul>
                                <div id="memoryEmptyMsg" class="text-muted mt-2" style="display:none;">No memories saved yet.</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="clearChatModal" tabindex="-1" aria-labelledby="clearChatModalLabel" aria-hidden="true"
        data-bs-backdrop="static">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="clearChatModalLabel">Clear Chat History</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>Are you sure you want to clear the chat history? This action cannot be undone.</p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-danger" id="confirmClearChat">Clear History</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Rename Chat Modal -->
    <div class="modal fade" id="renameChatModal" tabindex="-1" aria-labelledby="renameChatModalLabel"
        aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="renameChatModalLabel">Rename Chat</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="chatNameInput" class="form-label">Chat Name</label>
                        <input type="text" class="form-control" id="chatNameInput" placeholder="Enter chat name">
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="confirmRenameChat">Rename</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Delete Chat Modal -->
    <div class="modal fade" id="deleteChatModal" tabindex="-1" aria-labelledby="deleteChatModalLabel"
        aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="deleteChatModalLabel">Delete Chat</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>Are you sure you want to delete this chat? This action cannot be undone.</p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-danger" id="confirmDeleteChat">Delete</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Clear All Chats Modal -->
    <div class="modal fade" id="clearAllChatsModal" tabindex="-1" aria-labelledby="clearAllChatsModalLabel"
        aria-hidden="true" data-bs-backdrop="static">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="clearAllChatsModalLabel">Clear All Chats</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="alert alert-warning" role="alert">
                        <i class="bi bi-exclamation-triangle-fill me-2"></i>
                        <strong>Warning:</strong> This will permanently delete all chat conversations from your
                        browser's storage.
                    </div>
                    <p>Are you sure you want to clear all chats? This action cannot be undone.</p>
                    <p class="mb-0"><span class="fw-bold" id="clearAllChatsCount">0</span> chat(s) will be deleted.</p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-danger" id="confirmClearAllChats">
                        <i class="bi bi-trash3 me-2"></i>Clear All Chats
                    </button>
                </div>
            </div>
        </div>
    </div>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs-okaidia-theme@0.0.1/prism-okaidia.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1/plugins/autoloader/prism-autoloader.min.js"></script>

    <script type="module">
        import { bootstrapAlert } from "https://cdn.jsdelivr.net/npm/bootstrap-alert@1";
        import { asyncLLM } from "https://cdn.jsdelivr.net/npm/asyncllm@2";
        import { marked } from "https://cdn.jsdelivr.net/npm/marked@16/+esm";
        import DOMPurify from "https://cdn.jsdelivr.net/npm/dompurify@3/+esm";
        import prismjs from 'https://cdn.jsdelivr.net/npm/prismjs@1/+esm';

        async function loadLanguage(language) {
            try {
                const module = await import(`https://cdn.jsdelivr.net/npm/prismjs/components/prism-${language}.min.js`);
                console.debug(`${language} language loaded successfully.`);
                return module;
            } catch (err) {
                console.error(`Failed to load the ${language} language module:`, err);
            }
        }

        DOMPurify.addHook("afterSanitizeAttributes", async function (currentNode) {
            if (currentNode.tagName === "A" && currentNode.hasAttribute("href")) {
                currentNode.setAttribute("target", "_blank");
                currentNode.setAttribute("rel", "noopener noreferrer");
            }
        });

        const chatWindow = document.getElementById("chat-window");
        const chatForm = document.getElementById("chat-form");
        const userInput = document.getElementById("user-input");
        const clearChatBtn = document.getElementById("clear-chat-btn");

        const apiBaseUrlEl = document.getElementById("apiBaseUrl");
        const apiKeyEl = document.getElementById("apiKey");
        const serperApiKeyEl = document.getElementById("serperApiKey");
        const apiModelEl = document.getElementById("apiModel");
        const saveAndFetchModelsBtn = document.getElementById("saveAndFetchModels");
        const toolsEnabledSwitch = document.getElementById("toolsEnabledSwitch");
        const clearAllChatsBtn = document.getElementById("clearAllChatsBtn");
        const totalChatsCount = document.getElementById("totalChatsCount");
        const storageUsed = document.getElementById("storageUsed");

        const systemPrompt = {
            role: "system",
            content: `You are a helpful, tool-using AI assistant for a browser chat app.

Primary goals:
- Be concise, accurate, and actionable.
- Use Markdown for formatting (headings, bullets, tables, code fences).
- Prefer step-by-step clarity without fluff.

Tools available:
- googleSearch(query: string)
    - Use for up-to-date facts, current events, statistics, or when you are uncertain.
    - After using it, cite the top 1-3 relevant sources as Markdown links.
- callAIPipe(pipeline: string)
    - Use when the user explicitly asks to run a known dataflow/pipeline by name.
    - If the pipeline is unclear, ask a brief clarifying question.
- executeJavaScript(code: string)
    - Use for small calculations, parsing, date time or quick transformations in a sandbox.
    - Do not access the DOM, or perform destructive actions.
    - Keep outputs small; summarize longer results.
- openInBrowser(url: string)
    - Use to open a URL in a new browser tab.
    - Only use it when it's too necessary.
- addToMemory(memory: string)
    - Use to save concise, user-specified facts for long-term recall (e.g., "My favorite framework is React"). Do not add memories for trivial details.
- getMemories(): string[]
    - **Your memories are already in your context.** Do not call this tool to check them.
    - Only use this if the user explicitly asks you to list all saved memories.

Tool-use protocol:
- Call a tool only when it will materially improve the answer.
- Provide minimal, correct arguments. Never fabricate data or URLs.
- After tool results return, integrate them into your final answer with citations.
- Do not print tool-call JSON or internal IDs in your answer.

Style and limits:
- Keep responses short and impersonal. Avoid filler.
- Use fenced code blocks with language tags for code.
- If search is unavailable (e.g., missing API key) or a tool errors, say so briefly and proceed with best-effort reasoning.

Safety:
- Protect privacy; never request or reveal secrets or API keys.

Identity:
- Your Name: Anveshak.
- Your Developer: Varun Agnihotri <@PythonicVarun, code@pythonicvarun.me>`,
        };

        let conversationHistory = []; // Reference to the active chat's history array
        let settings = {};
        let chats = {}; // Object to store all chats
        let activeChat = null; // ID of the active chat
        let chatCounter = 0; // Counter for generating unique chat IDs
        let chatToRename = null; // Track which chat is being renamed
        let chatToDelete = null; // Track which chat is being deleted
        let isDraftChat = false; // Track if we're in a draft state (not yet saved)

        function generateChatId() {
            return 'chat_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function createNewChat() {
            const chatId = generateChatId();
            const chatName = `Chat ${Object.keys(chats).length + 1}`;

            chats[chatId] = {
                id: chatId,
                name: chatName,
                history: [systemPrompt],
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString()
            };

            return chatId;
        }

        function startDraftChat() {
            // Save current chat if we have one
            if (activeChat && chats[activeChat] && !isDraftChat) {
                chats[activeChat].history = [...conversationHistory];
                chats[activeChat].updatedAt = new Date().toISOString();
            }

            // Set up blank draft state
            activeChat = null;
            isDraftChat = true;
            conversationHistory = [systemPrompt];

            // Update UI
            updateChatList();
            updateChatTitle();
            displayHistory();

            // Don't save to localStorage yet
        }

        function switchToChat(chatId) {
            if (activeChat && chats[activeChat] && !isDraftChat) {
                // Save current conversation history to the active chat
                chats[activeChat].history = [...conversationHistory];
            }

            activeChat = chatId;
            isDraftChat = false; // We're switching to an existing chat, not a draft
            conversationHistory = chats[chatId] ? [...chats[chatId].history] : [systemPrompt];

            updateChatList();
            updateChatTitle();
            displayHistory();
            saveAllChats();
        }

        function updateChatTitle() {
            const titleEl = document.getElementById('chat-title');
            if (titleEl) {
                if (isDraftChat) {
                    titleEl.textContent = 'New Chat';
                } else if (activeChat && chats[activeChat]) {
                    titleEl.textContent = chats[activeChat].name;
                } else {
                    titleEl.textContent = 'New Chat';
                }
            }
        }

        function updateChatList() {
            const chatList = document.getElementById('chat-list');
            chatList.innerHTML = '';

            // Sort chats by updatedAt descending
            const sortedChats = Object.values(chats).sort((a, b) =>
                new Date(b.updatedAt) - new Date(a.updatedAt)
            );

            // console.log(sortedChats);

            sortedChats.forEach(chat => {
                const li = document.createElement('li');
                const isActive = !isDraftChat && chat.id === activeChat;
                li.className = `chat-item ${isActive ? 'active' : ''}`;
                li.innerHTML = `
                    <button class="chat-item-btn ${isActive ? 'active' : ''}"
                            onclick="switchToChat('${chat.id}')" data-chat-id="${chat.id}">
                        <span class="chat-title">${chat.name}</span>
                        <div class="chat-actions">
                            <button class="chat-action-btn" onclick="event.stopPropagation(); renameChat('${chat.id}')" title="Rename">
                                <i class="bi bi-pencil"></i>
                            </button>
                            <button class="chat-action-btn" onclick="event.stopPropagation(); deleteChat('${chat.id}')" title="Delete">
                                <i class="bi bi-trash"></i>
                            </button>
                        </div>
                    </button>
                `;
                chatList.appendChild(li);
            });
            updateStorageInfo();
        }

        function updateStorageInfo() {
            if (totalChatsCount) {
                totalChatsCount.textContent = Object.keys(chats).length;
            }

            if (storageUsed) {
                try {
                    const allData = localStorage.getItem("allChats") || "{}";
                    const settings = localStorage.getItem("agentSettings") || "{}";
                    const totalBytes = allData.length + settings.length;
                    const totalKB = Math.round(totalBytes / 1024 * 100) / 100;
                    storageUsed.textContent = `${totalKB} KB`;
                } catch (e) {
                    storageUsed.textContent = "Unknown";
                }
            }
        }

        function clearAllChats() {
            // Clear all chats and create a new default one
            chats = {};
            // const newChatId = createNewChat();
            // activeChat = newChatId;
            // isDraftChat = false;
            // conversationHistory = [...chats[newChatId].history];

            // // Update UI
            // updateChatList();
            // updateChatTitle();
            // displayHistory();

            startDraftChat();
            saveAllChats();
            updateStorageInfo();

            bootstrapAlert({
                title: "Success",
                body: "All chats have been cleared successfully.",
                color: "success"
            });
        }

        function saveAllChats() {
            // Save current conversation to active chat before saving (but not if it's a draft)
            if (activeChat && chats[activeChat] && !isDraftChat) {
                chats[activeChat].history = [...conversationHistory];
                // chats[activeChat].updatedAt = new Date().toISOString();
            }

            localStorage.setItem("allChats", JSON.stringify(chats));
            localStorage.setItem("activeChat", isDraftChat ? null : activeChat);
        }

        function loadAllChats() {
            const savedChats = localStorage.getItem("allChats");
            const savedActiveChat = localStorage.getItem("activeChat");

            if (savedChats) {
                chats = JSON.parse(savedChats);

                // If there are no chats, start in draft mode
                if (Object.keys(chats).length === 0) {
                    startDraftChat();
                    return;
                } else {
                    // Set active chat to saved one or first available
                    activeChat = savedActiveChat && chats[savedActiveChat] ? savedActiveChat : Object.keys(chats)[0];
                    isDraftChat = false;
                }
            } else {
                // Start in draft mode if no saved chats exist
                startDraftChat();
                return;
            }

            // Load conversation history for active chat
            conversationHistory = chats[activeChat] ? [...chats[activeChat].history] : [systemPrompt];
            updateChatList();
            updateChatTitle();
        }

        // Legacy support - migrate old conversation history
        function migrateLegacyData() {
            const legacyHistory = localStorage.getItem("conversationHistory");
            if (legacyHistory && Object.keys(chats).length === 0) {
                const history = JSON.parse(legacyHistory);
                if (history.length > 1) { // More than just system prompt
                    const chatId = createNewChat();
                    chats[chatId].name = "Imported Chat";
                    chats[chatId].history = history;
                    activeChat = chatId;
                    localStorage.removeItem("conversationHistory"); // Clean up
                }
            }
        }

        function saveConversationHistory() {
            // This function is kept for compatibility but now saves to the multi-chat system
            saveAllChats();
        }

        function loadConversationHistory() {
            // This function is kept for compatibility
            loadAllChats();
            migrateLegacyData();
        }

        function displayHistory() {
            chatWindow.innerHTML = "";
            const messagesToRender = conversationHistory.slice(1);

            if (messagesToRender.length === 0) {
                addMessageToUI("Hello! Please configure your provider and API keys in the <strong>Settings (‚öôÔ∏è)</strong> menu to get started.", "agent");
                return;
            }

            messagesToRender.forEach(message => {
                if (message.role === 'user') {
                    addMessageToUI(message.content, 'user');
                } else if (message.role === 'assistant') {
                    if (message.reasoning || message.tool_calls) {
                        const thinkingElement = addThinkingToUI();
                        if (message.reasoning) {
                            const reasoningEl = thinkingElement.querySelector(".reasoning-stream");
                            if (reasoningEl) reasoningEl.textContent = message.reasoning;
                        }

                        if (message.tool_calls) {
                            const toolCallsEl = thinkingElement.querySelector(".tool-calls-final");
                            const btn = thinkingElement.querySelector(".accordion-button");
                            if (toolCallsEl) {
                                toolCallsEl.querySelector("code").textContent = JSON.stringify(message.tool_calls, null, 4);
                                toolCallsEl.style.display = "block";
                                highlightSyntax(toolCallsEl);
                            }
                            if (btn) {
                                btn.innerHTML = `üß† Thinking... (Plans to use ${message.tool_calls.length} tool${message.tool_calls.length > 1 ? "s" : ""})`;
                            }
                        }
                    }

                    if (message.content) {
                        const messageElement = addMessageToUI("", "agent");
                        const cleanFragment = DOMPurify.sanitize(marked.parse(message.content), { RETURN_DOM_FRAGMENT: true });
                        highlightSyntax(cleanFragment).then(html => {
                            messageElement.appendChild(html);
                            messageElement.querySelectorAll("pre:not(:has(.copy-btn))").forEach((pre) => {
                                const btn = document.createElement("button");
                                btn.className = "copy-btn";
                                btn.textContent = "Copy";
                                pre.appendChild(btn);
                            });
                        });
                    }
                } else if (message.role === 'tool') {
                    addMessageToUI(`‚öôÔ∏è Used tool: <strong>${message.name}</strong>`, "tool");
                }
            });
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        const highlightSyntax = async (html) => {
            const codeBlocks = html.querySelectorAll("pre code[class*='language-']");

            for (const codeEle of codeBlocks) {
                const regex = /language-(\w+)/;
                const match = codeEle.className.match(regex);
                if (match) {
                    const language = match[1];
                    try {
                        await loadLanguage(language);

                        const highlightedCode = Prism.highlight(
                            codeEle.textContent,
                            Prism.languages[language],
                            language
                        );
                        codeEle.innerHTML = highlightedCode;
                    } catch (e) {
                        console.error(`Failed to highlight language ${language}`, e);
                    }
                }
            }

            return html;
        }

        async function generateChatTitle(userMessage) {
            if (!settings.apiKey || !settings.model) {
                return null; // Can't generate title without API access
            }

            try {
                const titlePrompt = {
                    role: "user",
                    content: `Based on this message: "${userMessage}"

Generate a short, descriptive title (3-5 words max) that captures the main topic or intent.

Examples:
- "Fix login bug" -> "Login Bug Fix"
- "How to center a div?" -> "CSS Centering Help"
- "Explain machine learning" -> "Machine Learning Basics"
- "Write a Python script" -> "Python Script Request"

Just respond with the title, nothing else:`
                };

                const requestBody = {
                    model: settings.model,
                    messages: [titlePrompt],
                    max_tokens: 20,
                    temperature: 0.7
                };

                const response = await fetch(`${settings.baseUrl}/chat/completions`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        Authorization: `Bearer ${settings.apiKey}`
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    throw new Error(`API Error: ${response.status}`);
                }

                const data = await response.json();
                const title = data.choices?.[0]?.message?.content?.trim();

                // Clean up the title and ensure it's reasonable
                if (title && title.length > 0 && title.length <= 50) {
                    // Remove quotes if present
                    return title.replace(/^["']|["']$/g, '');
                }

                return null;
            } catch (error) {
                console.error("Failed to generate chat title:", error);
                return null;
            }
        }

        function loadSettings() {
            const savedSettings = JSON.parse(localStorage.getItem("agentSettings")) || {};
            settings = {
                baseUrl: savedSettings.baseUrl || "https://api.openai.com/v1",
                apiKey: savedSettings.apiKey || "",
                serperApiKey: savedSettings.serperApiKey || "",
                model: savedSettings.model || "",
                models: savedSettings.models || [],
                toolsEnabled: savedSettings.toolsEnabled !== false, // Default: true
            };

            apiBaseUrlEl.value = settings.baseUrl;
            apiKeyEl.value = settings.apiKey;
            serperApiKeyEl.value = settings.serperApiKey;
            toolsEnabledSwitch.checked = settings.toolsEnabled;
            populateModelDropdown(settings.models);
            if (settings.model) apiModelEl.value = settings.model;
        }

        function saveSettings() {
            localStorage.setItem("agentSettings", JSON.stringify(settings));
        }

        function populateModelDropdown(models) {
            apiModelEl.innerHTML = "";
            if (models && models.length > 0) {
                models.forEach((modelName) => {
                    const option = document.createElement("option");
                    option.value = modelName;
                    option.textContent = modelName;
                    apiModelEl.appendChild(option);
                });
                apiModelEl.disabled = false;
            } else {
                apiModelEl.innerHTML = "<option>No models found. Fetch first.</option>";
                apiModelEl.disabled = true;
            }
        }

        saveAndFetchModelsBtn.addEventListener("click", async () => {
            const btnSpinner = saveAndFetchModelsBtn.querySelector(".spinner-border");
            btnSpinner.classList.remove("d-none");
            saveAndFetchModelsBtn.disabled = true;

            const baseUrl = apiBaseUrlEl.value.trim();
            const apiKey = apiKeyEl.value.trim();

            try {
                if (!apiKey) throw new Error("LLM Provider API Key is required to fetch models.");
                const response = await fetch(`${baseUrl}/models`, { headers: { Authorization: `Bearer ${apiKey}` } });
                if (!response.ok) throw new Error("Failed to fetch models. Check URL and API Key.");
                const data = await response.json();
                const models = data.data.map((m) => m.id).sort();

                settings.baseUrl = baseUrl;
                settings.models = models;
                settings.model = models[0] || "";
                saveSettings();
                populateModelDropdown(models);
                apiModelEl.value = settings.model;
                bootstrapAlert({ title: "Success", body: `Found ${models.length} models. Settings saved.`, color: "success" });
            } catch (error) {
                bootstrapAlert({ title: "Error", body: error.message, color: "danger" });
            } finally {
                btnSpinner.classList.add("d-none");
                saveAndFetchModelsBtn.disabled = false;
            }
        });

        apiKeyEl.addEventListener("change", () => {
            settings.apiKey = apiKeyEl.value.trim();
            saveSettings();
        });

        serperApiKeyEl.addEventListener("change", () => {
            settings.serperApiKey = serperApiKeyEl.value.trim();
            saveSettings();
        });

        apiModelEl.addEventListener("change", () => {
            settings.model = apiModelEl.value;
            saveSettings();
        });

        toolsEnabledSwitch.addEventListener("change", () => {
            settings.toolsEnabled = toolsEnabledSwitch.checked;
            saveSettings();
        });

        // Tools
        async function googleSearch(query) {
            if (!settings.serperApiKey) {
                bootstrapAlert({ title: "Configuration Needed", body: "Please set your Serper.dev API key in Settings > API Keys.", color: "warning" });
                throw new Error("Serper API key not provided.");
            }

            bootstrapAlert({ body: `Searching Google for: "${query}"`, color: "info" });
            try {
                const response = await fetch("https://google.serper.dev/search", {
                    method: "POST",
                    headers: { "X-API-KEY": settings.serperApiKey, "Content-Type": "application/json" },
                    body: JSON.stringify({ q: query }),
                });
                if (!response.ok) throw new Error(`API Error: ${response.status} ${response.statusText}`);
                const data = await response.json();
                const simplifiedResults = (data.organic || []).slice(0, 5).map((item) => ({ title: item.title, link: item.link, snippet: item.snippet }));
                return JSON.stringify(simplifiedResults);
            } catch (error) {
                bootstrapAlert({ title: "Search Failed", body: error.message, color: "danger" });
                return JSON.stringify({ error: `An error occurred during search: ${error.message}` });
            }
        }

        async function callAIPipe(pipeline, data) {
            return JSON.stringify({ success: true });
        }

        async function executeJavaScript(code) {
            const workerSource = `
            self.onmessage = async (e) => {
                const { id, code } = e.data || {};

                const serialize = (obj) => {
                    try {
                    const seen = new WeakSet();
                    return JSON.stringify(obj, function (k, v) {
                        if (typeof v === 'bigint') return v.toString() + 'n';
                        if (typeof v === 'function') return '[Function ' + (v.name || 'anonymous') + ']';
                        if (typeof v === 'symbol') return v.toString();
                        if (v && typeof v === 'object') {
                        if (seen.has(v)) return '[Circular]';
                        seen.add(v);
                        }
                        return v;
                    });
                    } catch (e) {
                    return JSON.stringify({ error: 'Could not serialize value' });
                    }
                };

                const reply = (payload) => {
                    try {
                        const out = { id, type: payload.type };
                        if (payload.type === 'log') {
                            out.level = payload.level;
                            out.args = serialize(payload.args);
                        } else if (payload.type === 'result') {
                            out.result = serialize(payload.result);
                        } else if (payload.type === 'error') {
                            out.error = serialize(payload.error);
                        } else {
                            out.payload = serialize(payload);
                        }
                        self.postMessage(out);
                    } catch (err) {
                        try {
                            self.postMessage({ id, type: 'error', error: serialize('postMessage failed: ' + String(err)) });
                        } catch (_) {
                            // pass
                        }
                    }
                };

                const consoleProxy = {
                    log: (...args) => reply({ type: 'log', level: 'log', args }),
                    info: (...args) => reply({ type: 'log', level: 'info', args }),
                    warn: (...args) => reply({ type: 'log', level: 'warn', args }),
                    error: (...args) => reply({ type: 'log', level: 'error', args })
                };

                try {
                    // Shadow globals inside evaluated code
                    const prelude = 'const window=undefined,document=undefined,postMessage=undefined,importScripts=undefined,XMLHttpRequest=undefined,fetch=undefined,WebSocket=undefined,navigator=undefined,location=undefined,localStorage=undefined,sessionStorage=undefined,FileReader=undefined,caches=undefined,globalThis=undefined,self=undefined;';

                    const wrapped = '"use strict";\\n' + prelude + '\\nreturn (async () => { try { return eval(' + JSON.stringify(code || '') + '); } catch (e) { throw e } })()';
                    const fn = new Function('console', wrapped);
                    const result = await fn(consoleProxy);
                    reply({ type: 'result', result });
                } catch (err) {
                    reply({ type: 'error', error: err && err.message ? err.message : String(err) });
                }
            };
            `;

            const blobUrl = URL.createObjectURL(new Blob([workerSource], { type: "application/javascript" }));
            const worker = new Worker(blobUrl);
            const id = Math.random().toString(36).slice(2);
            const logs = [];

            const SAFE_JSON = (obj) => {
                try {
                    const seen = new WeakSet();
                    const json = JSON.stringify(obj, (k, v) => {
                        if (typeof v === 'bigint') return `${v}n`;
                        if (typeof v === 'function') return `[Function ${v.name || 'anonymous'}]`;
                        if (typeof v === 'symbol') return v.toString();
                        if (v && typeof v === 'object') {
                            if (seen.has(v)) return '[Circular]';
                            seen.add(v);
                        }
                        return v;
                    });
                    if (json.length > 4000) {
                        return JSON.stringify({ truncated: true, length: json.length, preview: json.slice(0, 4000) + '‚Ä¶' });
                    }
                    return json;
                } catch (_) {
                    return JSON.stringify({ error: 'Result not serializable' });
                }
            };

            return await new Promise((resolve) => {
                let settled = false;
                const cleanup = () => {
                    if (!settled) {
                        settled = true;
                        worker.terminate();
                        URL.revokeObjectURL(blobUrl);
                    }
                };

                const timeoutMs = 2000;
                const timer = setTimeout(() => {
                    cleanup();
                    resolve(JSON.stringify({ error: 'Execution timed out' }));
                }, timeoutMs);

                worker.onmessage = (ev) => {
                    const msg = ev.data || {};
                    if (msg.id !== id) return;

                    if (msg.type === 'log') {
                        let args;
                        try { args = JSON.parse(msg.args); } catch (_) { args = [msg.args]; }
                        logs.push({ level: msg.level || 'log', args });
                        return;
                    }

                    clearTimeout(timer);
                    cleanup();

                    if (msg.type === 'result') {
                        let res;
                        try { res = JSON.parse(msg.result); } catch (_) { res = msg.result; }
                        resolve(SAFE_JSON({ result: res, logs }));
                    } else if (msg.type === 'error') {
                        let err;
                        try { err = JSON.parse(msg.error); } catch (_) { err = msg.error; }
                        resolve(SAFE_JSON({ error: err, logs }));
                    } else {
                        resolve(SAFE_JSON({ error: 'Unknown worker message', msg, logs }));
                    }
                };

                worker.onerror = (err) => {
                    clearTimeout(timer);
                    cleanup();
                    resolve(SAFE_JSON({ error: err.message || 'Worker error', logs }));
                };

                worker.postMessage({ id, code: String(code || '') });
            });
        }

        async function openInBrowser(url) {
            try {
                window.open(url, '_blank');
                return JSON.stringify({ success: true, message: "Successfully opened link in the browser." })
            } catch {
                return JSON.stringify({ success: false, message: "Failed to open link in the browser." })
            }
        }

        // Memory Tools
        function addToMemory(memory) {
            // console.log("Adding memory:", memory);
            if (!memory || typeof memory !== "string" || !memory.trim()) {
                return JSON.stringify({ success: false, message: "Memory must be a non-empty string." });
            }

            let memories = [];
            try {
                memories = JSON.parse(localStorage.getItem("agentMemories") || "[]");
            } catch {
                memories = [];
            }

            memories.push({ memory, timestamp: new Date().toISOString() });
            localStorage.setItem("agentMemories", JSON.stringify(memories));
            return JSON.stringify({ success: true, message: "Memory saved." });
        }

        function getMemories() {
            try {
                const memories = JSON.parse(localStorage.getItem("agentMemories") || "[]");
                return JSON.stringify(memories);
            } catch {
                return JSON.stringify([]);
            }
        }

        const availableTools = { googleSearch, callAIPipe, executeJavaScript, openInBrowser, addToMemory, getMemories };
        const tools = [
            { type: "function", function: { name: "googleSearch", description: "Search Google for recent results.", parameters: { type: "object", properties: { query: { type: "string" } } } } },
            { type: "function", function: { name: "callAIPipe", description: "Run a dataflow.", parameters: { type: "object", properties: { pipeline: { type: "string" } } } } },
            { type: "function", function: { name: "executeJavaScript", description: "Execute JS code.", parameters: { type: "object", properties: { code: { type: "string" } } } } },
            { type: "function", function: { name: "openInBrowser", description: "Open a URL in the browser.", parameters: { type: "object", properties: { url: { type: "string" } } } } },
            { type: "function", function: { name: "addToMemory", description: "Save a memory string to persistent storage.", parameters: { type: "object", properties: { memory: { type: "string", description: "The memory to save." } }, required: ["memory"] } } },
            { type: "function", function: { name: "getMemories", description: "Retrieve all saved memories.", parameters: { type: "object", properties: {} } } },
        ];

        async function runConversation() {
            toggleLoading(true);
            let messageElement = null,
                thinkingElement = null,
                lastEventTools = [],
                fullReasoningText = "",
                fullContent = "";

            try {
                let memories = [];
                try {
                    memories = JSON.parse(localStorage.getItem("agentMemories") || "[]");
                } catch {
                    memories = [];
                }

                const baseSystemPrompt = systemPrompt.content;
                let dynamicSystemPromptContent = baseSystemPrompt;

                if (memories.length > 0) {
                    const memoryStrings = memories.map(m => `- ${m.memory}`).join('\n');
                    dynamicSystemPromptContent += `

---
Here are some memories you have saved. Use them for context, but do not mention them unless the user's query is directly related.
${memoryStrings}
---
`;
                }

                const dynamicSystemPrompt = { role: "system", content: dynamicSystemPromptContent };

                // Filter messages before sending and inject memories
                const messagesToSend = conversationHistory.slice(1).map(msg => {
                    if (msg.role === 'assistant' && msg.reasoning) {
                        const { reasoning, ...messageWithoutReasoning } = msg;
                        return messageWithoutReasoning;
                    }
                    return msg;
                });
                messagesToSend.unshift(dynamicSystemPrompt);


                const requestBody = {
                    model: settings.model,
                    messages: messagesToSend,
                    stream: true
                };

                if (settings.toolsEnabled) {
                    requestBody.tools = tools;
                    requestBody.tool_choice = "auto";
                }
                const request = {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        Authorization: `Bearer ${settings.apiKey}`
                    },
                    body: JSON.stringify(requestBody)
                };

                for await (const event of asyncLLM(`${settings.baseUrl}/chat/completions`, request)) {
                    const reasoningDelta = event.message?.choices?.[0]?.delta?.reasoning;
                    if ((reasoningDelta || event.tools) && !thinkingElement) {
                        thinkingElement = addThinkingToUI();
                    }

                    if (reasoningDelta) {
                        fullReasoningText += reasoningDelta;
                        const el = thinkingElement.querySelector(".reasoning-stream");
                        if (el) el.textContent = fullReasoningText;
                    }

                    if (event.content && !messageElement) {
                        messageElement = addMessageToUI("", "agent");
                    }

                    if (messageElement && event.content) {
                        const cleanFragment = DOMPurify.sanitize(marked.parse(event.content), { RETURN_DOM_FRAGMENT: true });
                        const html = await highlightSyntax(cleanFragment);

                        messageElement.replaceChildren();
                        messageElement.appendChild(html);
                        fullContent = event.content;
                    }

                    if (event.tools) {
                        lastEventTools = event.tools;
                    }

                    if (event.error) throw new Error(JSON.stringify(event.error));
                    chatWindow.scrollTop = chatWindow.scrollHeight;
                }

                if (messageElement) {
                    const cleanFragment = DOMPurify.sanitize(marked.parse(fullContent), { RETURN_DOM_FRAGMENT: true });
                    const html = await highlightSyntax(cleanFragment);

                    messageElement.replaceChildren();
                    messageElement.appendChild(html);
                    messageElement.querySelectorAll("pre").forEach((pre) => {
                        const btn = document.createElement("button");
                        btn.className = "copy-btn";
                        btn.textContent = "Copy";
                        pre.appendChild(btn);
                    });
                }

                const finalToolCalls = lastEventTools.map((t) => ({ id: t.id, type: "function", function: { name: t.name, arguments: t.args } }));
                const agentResponse = {
                    role: "assistant",
                    content: fullContent,
                    tool_calls: finalToolCalls.length > 0 ? finalToolCalls : undefined,
                    reasoning: fullReasoningText || undefined
                };
                conversationHistory.push(agentResponse);
                saveConversationHistory();

                if (agentResponse.tool_calls) {
                    if (thinkingElement) {
                        const el = thinkingElement.querySelector(".tool-calls-final");
                        const btn = thinkingElement.querySelector(".accordion-button");
                        if (el) {
                            el.querySelector("code").textContent = JSON.stringify(finalToolCalls, null, 4);
                            el.style.display = "block";
                            await highlightSyntax(el);
                        }
                        if (btn) {
                            btn.innerHTML = `üß† Thinking... (Plans to use ${finalToolCalls.length} tool${finalToolCalls.length > 1 ? "s" : ""})`;
                        }
                    }

                    for (const toolCall of agentResponse.tool_calls) {
                        const { name, arguments: args } = toolCall.function;
                        addMessageToUI(`‚öôÔ∏è Using tool: <strong>${name}</strong>`, "tool");
                        const toolOutput = await availableTools[name](...Object.values(JSON.parse(args)));
                        conversationHistory.push({ tool_call_id: toolCall.id, role: "tool", name, content: toolOutput });
                        saveConversationHistory();
                    }
                    await runConversation();
                } else {
                    toggleLoading(false);
                    // Update chat list to reflect the new activity order
                    updateChatList();
                }
            } catch (error) {
                bootstrapAlert({ title: "Error", body: error.message, color: "danger" });
                toggleLoading(false);
            }
        }

        chatForm.addEventListener("submit", async (e) => {
            e.preventDefault();
            const userText = userInput.value.trim();
            if (!userText) return;

            if (!settings.apiKey || !settings.model) {
                bootstrapAlert({ title: "Configuration Needed", body: "Please set your API Key and fetch models in the Settings (‚öôÔ∏è) menu.", color: "warning" });
                new bootstrap.Modal(document.getElementById("appSettingsModal")).show();
                return;
            }

            // If we're in draft mode, create a new chat now
            if (isDraftChat) {
                const newChatId = createNewChat();
                activeChat = newChatId;
                isDraftChat = false;

                // Set temporary name initially (will be replaced by AI-generated title)
                const tempName = userText.length > 15 ? userText.substring(0, 15) + "..." : userText;
                chats[activeChat].name = tempName;
                chats[activeChat].updatedAt = new Date().toISOString();

                updateChatList();
                updateChatTitle();

                // Show title generation in progress
                const titleEl = document.getElementById('chat-title');
                if (titleEl) {
                    titleEl.innerHTML = `${tempName} <small class="text-muted"><i class="bi bi-three-dots"></i></small>`;
                }

                // Generate AI title in the background
                generateChatTitle(userText).then(aiTitle => {
                    if (aiTitle && activeChat && chats[activeChat]) {
                        chats[activeChat].name = aiTitle;
                        chats[activeChat].updatedAt = new Date().toISOString();
                        updateChatList();
                        updateChatTitle();
                        saveAllChats();
                    } else {
                        // Fallback to temp name if AI generation failed
                        updateChatTitle();
                    }
                }).catch(error => {
                    console.error("Title generation failed:", error);
                    updateChatTitle(); // Remove loading indicator
                });

            } else if (activeChat && chats[activeChat] && chats[activeChat].history.length === 1) {
                // Auto-rename chat if it's the first message in an existing chat
                const tempName = userText.length > 30 ? userText.substring(0, 30) + "..." : userText;
                chats[activeChat].name = tempName;
                chats[activeChat].updatedAt = new Date().toISOString();
                updateChatList();
                updateChatTitle();

                // Show title generation in progress
                const titleEl = document.getElementById('chat-title');
                if (titleEl) {
                    titleEl.innerHTML = `${tempName} <small class="text-muted"><i class="bi bi-three-dots"></i></small>`;
                }

                // Generate AI title in the background
                generateChatTitle(userText).then(aiTitle => {
                    if (aiTitle && activeChat && chats[activeChat]) {
                        chats[activeChat].name = aiTitle;
                        chats[activeChat].updatedAt = new Date().toISOString();
                        updateChatList();
                        updateChatTitle();
                        saveAllChats();
                    } else {
                        // Fallback to temp name if AI generation failed
                        updateChatTitle();
                    }
                }).catch(error => {
                    console.error("Title generation failed:", error);
                    updateChatTitle(); // Remove loading indicator
                });
            } else if (activeChat && chats[activeChat]) {
                // Update timestamp for existing chat with new message
                chats[activeChat].updatedAt = new Date().toISOString();
                updateChatList();
            }

            addMessageToUI(userText, "user");
            conversationHistory.push({ role: "user", content: userText });
            saveConversationHistory();
            userInput.value = "";
            await runConversation();
        });

        function addMessageToUI(content, role) {
            const w = document.createElement("div");
            if (role === "user" || role === "agent") {
                w.className = `message-wrapper ${role}`;
                const a = document.createElement("div");
                a.className = `avatar avatar-${role}`;
                a.textContent = role === "user" ? "üë§" : "ü§ñ";
                const m = document.createElement("div");
                m.className = `message ${role}-message`;
                if (role === 'user') {
                    m.innerHTML = DOMPurify.sanitize(marked.parseInline(content));
                } else {
                    m.innerHTML = content;
                }
                w.appendChild(a);
                w.appendChild(m);
                chatWindow.appendChild(w);
                chatWindow.scrollTop = chatWindow.scrollHeight;
                return m;
            } else {
                w.className = "system-event";
                const m = document.createElement("div");
                m.className = "tool-message";
                m.innerHTML = content;
                w.appendChild(m);
                chatWindow.appendChild(w);
                chatWindow.scrollTop = chatWindow.scrollHeight;
                return m;
            }
        }

        let accordionCounter = 0;
        function addThinkingToUI() {
            accordionCounter++;
            const id = `accordion-${accordionCounter}`;
            const html = `
            <div class="accordion my-2 system-event" id="${id}">
                <div class="accordion-item">
                    <h2 class="accordion-header">
                        <button class="accordion-button collapsed py-2" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-${id}">
                            üß† Thinking...
                        </button>
                    </h2>
                    <div id="collapse-${id}" class="accordion-collapse collapse" data-bs-parent="#${id}">
                        <div class="accordion-body">
                            <div class="reasoning-stream"></div>
                            <div class="tool-calls-final" style="display: none;">
                                <pre><code class="language-json"></code></pre>
                            </div>
                        </div>
                    </div>
                </div>
            </div>`;
            chatWindow.insertAdjacentHTML("beforeend", html);
            chatWindow.scrollTop = chatWindow.scrollHeight;
            return document.getElementById(id);
        }

        chatWindow.addEventListener("click", (e) => {
            if (e.target.classList.contains("copy-btn")) {
                const pre = e.target.closest("pre");
                const code = pre.querySelector("code").textContent;
                navigator.clipboard.writeText(code).then(() => {
                    e.target.textContent = "Copied!";
                    setTimeout(() => {
                        e.target.textContent = "Copy";
                    }, 2000);
                });
            }
        });

        // Chat management event handlers
        const clearChatBtnDesktop = document.getElementById("clear-chat-btn-desktop");
        const newChatBtn = document.getElementById("new-chat-btn");
        const mobileMenuBtn = document.getElementById("mobile-menu-btn");
        const sidebar = document.getElementById("sidebar");
        const sidebarOverlay = document.getElementById("sidebar-overlay");

        // New chat button
        newChatBtn.addEventListener("click", () => {
            startDraftChat();
        });

        // Mobile menu toggle
        mobileMenuBtn.addEventListener("click", () => {
            sidebar.classList.toggle("show");
            sidebarOverlay.classList.toggle("show");
        });

        // Close sidebar when clicking overlay
        sidebarOverlay.addEventListener("click", () => {
            sidebar.classList.remove("show");
            sidebarOverlay.classList.remove("show");
        });

        clearChatBtn.addEventListener("click", () => deleteChat(activeChat));
        clearChatBtnDesktop.addEventListener("click", () => deleteChat(activeChat));

        // Confirm clear chat
        document.getElementById("confirmClearChat").addEventListener("click", () => {
            if (isDraftChat) {
                // If in draft mode, just reset the conversation
                conversationHistory = [systemPrompt];
                displayHistory();
            } else if (activeChat && chats[activeChat]) {
                chats[activeChat].history = [systemPrompt];
                conversationHistory = [systemPrompt];
                chats[activeChat].updatedAt = new Date().toISOString();
                saveAllChats();
                displayHistory();
            }
            bootstrap.Modal.getInstance(document.getElementById("clearChatModal")).hide();
        });

        // Rename chat functions
        function renameChat(chatId) {
            chatToRename = chatId;
            const chatNameInput = document.getElementById("chatNameInput");
            chatNameInput.value = chats[chatId].name;
            const renameChatModal = new bootstrap.Modal(document.getElementById("renameChatModal"));
            renameChatModal.show();
            setTimeout(() => chatNameInput.focus(), 100);
        }

        // Confirm rename chat
        document.getElementById("confirmRenameChat").addEventListener("click", () => {
            const newName = document.getElementById("chatNameInput").value.trim();
            if (newName && chatToRename && chats[chatToRename]) {
                chats[chatToRename].name = newName;
                chats[chatToRename].updatedAt = new Date().toISOString();
                updateChatList();
                updateChatTitle();
                saveAllChats();
            }
            bootstrap.Modal.getInstance(document.getElementById("renameChatModal")).hide();
            chatToRename = null;
        });

        // Handle enter key in rename input
        document.getElementById("chatNameInput").addEventListener("keypress", (e) => {
            if (e.key === "Enter") {
                document.getElementById("confirmRenameChat").click();
            }
        });

        // Delete chat functions
        function deleteChat(chatId) {
            chatToDelete = chatId;
            const deleteChatModal = new bootstrap.Modal(document.getElementById("deleteChatModal"));
            deleteChatModal.show();
        }

        // Confirm delete chat
        document.getElementById("confirmDeleteChat").addEventListener("click", () => {
            if (chatToDelete && chats[chatToDelete]) {
                delete chats[chatToDelete];

                // If we deleted the active chat, switch to another one or start draft mode
                if (chatToDelete === activeChat) {
                    const remainingChats = Object.keys(chats);
                    if (remainingChats.length > 0) {
                        switchToChat(remainingChats[0]);
                    } else {
                        startDraftChat();
                    }
                } else {
                    updateChatList();
                    saveAllChats();
                }
            }
            bootstrap.Modal.getInstance(document.getElementById("deleteChatModal")).hide();
            chatToDelete = null;
        });

        // Clear all chats functions
        clearAllChatsBtn.addEventListener("click", () => {
            const clearAllChatsModal = new bootstrap.Modal(document.getElementById("clearAllChatsModal"));
            const countElement = document.getElementById("clearAllChatsCount");
            if (countElement) {
                countElement.textContent = Object.keys(chats).length;
            }
            clearAllChatsModal.show();
        });

        // Confirm clear all chats
        document.getElementById("confirmClearAllChats").addEventListener("click", () => {
            clearAllChats();
            bootstrap.Modal.getInstance(document.getElementById("clearAllChatsModal")).hide();
        });

        // Update storage info when Data tab is shown
        document.getElementById("data-tab").addEventListener("click", () => {
            updateStorageInfo();
        });

        // Make functions globally available for onclick handlers
        window.switchToChat = switchToChat;
        window.renameChat = renameChat;
        window.deleteChat = deleteChat;

        function toggleLoading(isLoading) {
            const btn = document.getElementById("submit-button");
            userInput.disabled = isLoading;
            btn.disabled = isLoading;
            btn.innerHTML = isLoading ? '<span class="spinner-border spinner-border-sm"></span>' : "‚û§";
            if (!isLoading) userInput.focus();
        }

        // --- Memory UI in Data Tab ---
        function renderMemoryList() {
            const memoryList = document.getElementById("memoryList");
            const memoryEmptyMsg = document.getElementById("memoryEmptyMsg");
            if (!memoryList || !memoryEmptyMsg) return;
            let memories = [];
            try {
                memories = JSON.parse(localStorage.getItem("agentMemories") || "[]");
            } catch { memories = []; }
            memoryList.innerHTML = "";
            if (!memories.length) {
                memoryEmptyMsg.style.display = "block";
                memoryList.style.display = "none";
                return;
            }
            memoryEmptyMsg.style.display = "none";
            memoryList.style.display = "block";
            memories.slice().reverse().forEach(m => {
                const li = document.createElement("li");
                li.className = "list-group-item d-flex justify-content-between align-items-start py-2 px-2";
                li.innerHTML = `<span>${DOMPurify.sanitize(m.memory)}</span><span class='text-muted small ms-2'>${new Date(m.timestamp).toLocaleString()}</span>`;
                memoryList.appendChild(li);
            });
        }

        // Render memory list only when Data tab is shown
        document.getElementById("data-tab").addEventListener("click", renderMemoryList);

        // Clear all memories (button is in Data tab)
        document.getElementById("data-tab-pane").addEventListener("click", function(e) {
            if (e.target && e.target.id === "clearMemoriesBtn") {
                if (confirm("Are you sure you want to clear all memories? This cannot be undone.")) {
                    localStorage.removeItem("agentMemories");
                    renderMemoryList();
                    bootstrapAlert({ title: "Memory Cleared", body: "All memories have been deleted.", color: "success" });
                }
            }
        });

        loadSettings();
        loadConversationHistory();
        displayHistory();
        updateStorageInfo();
    </script>
</body>

</html>